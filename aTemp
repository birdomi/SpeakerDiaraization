class RNN_Model(Model):
    def _build_net(self):
        self.LSTM_layer1=35
        self.LSTM_layer2=35
        self.LSTM_layer3=30

        self.FC_layer1=self.LSTM_layer3*2
        self.FC_layer2=30
        self.FC_layer3=2

        self.X=tf.placeholder(tf.float32,[None,320,38])
        self.Y=tf.placeholder(tf.int32,[None,320])
        self.keep_prob=tf.placeholder(tf.float32)

        self._RNN1_cell=tf.contrib.rnn.BasicLSTMCell(self.LSTM_layer1)
        self.RNN1_cell=tf.contrib.rnn.DropoutWrapper(self._RNN1_cell,output_keep_prob=self.keep_prob)

        self._RNN2_cell=tf.contrib.rnn.BasicLSTMCell(self.LSTM_layer2)
        self.RNN2_cell=tf.contrib.rnn.DropoutWrapper(self._RNN2_cell,output_keep_prob=self.keep_prob)
        
        self._RNN3_cell=tf.contrib.rnn.BasicLSTMCell(self.LSTM_layer3)
        self.RNN3_cell=tf.contrib.rnn.DropoutWrapper(self._RNN3_cell,output_keep_prob=self.keep_prob)

        self.cell_fw=[self.RNN1_cell,self.RNN3_cell]
        self.cell_bw=[self.RNN1_cell,self.RNN3_cell]
        self.RNN_output,_,_=tf.contrib.rnn.stack_bidirectional_dynamic_rnn(self.cell_fw,self.cell_bw,self.X,dtype=tf.float32)

        self.fc_input=tf.reshape(self.RNN_output,[-1,self.FC_layer1])

        self.FC1=tf.contrib.layers.fully_connected(self.fc_input,self.FC_layer1)
        self.FC2=tf.contrib.layers.fully_connected(self.FC1,self.FC_layer2)
        self.FC3=tf.contrib.layers.fully_connected(self.FC2,self.FC_layer3,activation_fn=None)

        self.outputs=tf.reshape(self.FC3,[-1,320,2])

        self.cost=tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.outputs,labels=self.Y))
        self.optimizer=tf.train.AdamOptimizer(learning_rate=self.learning_rate).minimize(self.cost)

    def Accuracy(self,x,y):
        x_prediction=np.reshape(self.Predict(x),[-1])
        y_prediction=np.reshape(y,[-1])
        print(len(x_prediction)," ",len(y_prediction))
        
        check_for_changePoint=0
        check_for_falseAlarm=0
        total_changePoint=0
        total_non_changePoint=0
        accuracy_changePoint=0.0
        accuracy_non_changePoint=0.0
        for i in range(len(x_prediction)):            
            if(y_prediction[i]==1):
                total_changePoint=total_changePoint+1
                if(x_prediction[i]==1):
                    check_for_changePoint=check_for_changePoint+1
            else:
                total_non_changePoint=total_non_changePoint+1
                if(x_prediction[i]==0):
                    check_for_falseAlarm=check_for_falseAlarm+1

        if(total_changePoint!=0):
            accuracy_changePoint=(float)(check_for_changePoint/total_changePoint)
        if(total_non_changePoint!=0):
            accuracy_non_changePoint=(float)(check_for_falseAlarm/total_non_changePoint)
                
        return accuracy_changePoint,accuracy_non_changePoint

    def Make_Result(self,x_test,keep_prob=1.0):
        result=np.reshape(self.predict(x_test),[-1])

        Temp=[]
        time=(int)(time_windowLength/time_windowSteps)
        
        for i in range(4):
            if(i==0):
                for j in range(time_windowSteps):
                    Temp.append(result[j])
            if(i==1):
                for j in range(time_windowSteps,2*time_windowSteps):
                    index=j
                    tmp_sum=0
                    for k in range(2):
                        tmp_sum+=result[index+3*k*time_windowSteps]
                    Temp.append(tmp_sum/2.0)
            if(i==2):
                for j in range(2*time_windowSteps,3*time_windowSteps):
                    index=j
                    tmp_sum=0
                    for k in range(3):
                        tmp_sum+=result[index+3*k*time_windowSteps]
                    Temp.append(tmp_sum/3.0)

        for i in range(len(x_test)-3):
            step=(i+1)*time_windowLength
            for j in range(step-time_windowSteps,step):
                index=j
                tmp_sum=0
                for k in range(4):
                    tmp_sum+=result[index+3*k*time_windowSteps]
                Temp.append(tmp_sum/4.0)

        for i in range(len(x_test)-3,len(x_test)):
            step=(i+1)*time_windowLength

            if(i==len(x_test)-3):
               for j in range(step-time_windowSteps,step):
                   index=j
                   tmp_sum=0
                   for k in range(3):
                       tmp_sum+=result[index+3*k*time_windowSteps]
                   Temp.append(tmp_sum/3.0)
            if(i==len(x_test)-2):
                for j in range(step-time_windowSteps,step):
                   index=j
                   tmp_sum=0
                   for k in range(2):
                       tmp_sum+=result[index+3*k*time_windowSteps]
                   Temp.append(tmp_sum/2.0)
            if(i==len(x_test)-1):
                step=(i+1)*time_windowLength
                for j in range(step-time_windowSteps,step):
                    Temp.append(result[j])
        return Temp
